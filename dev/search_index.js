var documenterSearchIndex = {"docs":
[{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"","category":"page"},{"location":"library/#Public","page":"Library","title":"Public","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [BellDiagonalQudits]\nPrivate = false","category":"page"},{"location":"library/#BellDiagonalQudits.AnalysedCoordState","page":"Library","title":"BellDiagonalQudits.AnalysedCoordState","text":"Representing an entanglement analyzed Bell diagonal state.\n\ncoordState: The analyzed CoordState\nkernel: true if kernel check successful, else false. missing if entanglement check not applied.\nspinrep: true if spinrep check successful, else false. missing if entanglement check not applied.\nppt: true if ppt check successful, else false. missing if entanglement check not applied.\nrealign: true if realignment check successful, else false. missing if entanglement check not applied.\nconcurrence: true if concurrence check successful, else false. missing if entanglement check not applied.\nmub: true if mub check successful, else false. missing if entanglement check not applied.\nnumericEW: true if numericEW check successful, else false. missing if entanglement check not applied.\n\n\n\n\n\n","category":"type"},{"location":"library/#BellDiagonalQudits.AnalysisSpecification","page":"Library","title":"BellDiagonalQudits.AnalysisSpecification","text":"Specification which entanglement checks to use.\n\nkernelCheck\nspinrepCheck\npptCheck\nrealignmentCheck \nmubCheck \nnumericEwCheck\nuseSymmetries\n\n\n\n\n\n","category":"type"},{"location":"library/#BellDiagonalQudits.BoundedCoordEW","page":"Library","title":"BellDiagonalQudits.BoundedCoordEW","text":"Represents an entanglement witness W with extrema to detect entangled Bell diagonal states.\n\ncoords: Coordinates in Bell basis.\nupperBound: Upper bound of tr W rho satisfied by all separable states rho. Violation detects entanglement.\nlowerBound: Lower bound of tr W rho satisfied by all separable states rho. Violation detects entanglement.\ncheckedIterations: Number of iterations used in the optimization of bounds.\n\n\n\n\n\n","category":"type"},{"location":"library/#BellDiagonalQudits.CoordState","page":"Library","title":"BellDiagonalQudits.CoordState","text":"Represents a Bell diagonal state in Bell basis.\n\ncoords: Coordinates in Bell basis. \neClass: Entanglement class of the represented state.\n\n\n\n\n\n","category":"type"},{"location":"library/#BellDiagonalQudits.DensityState","page":"Library","title":"BellDiagonalQudits.DensityState","text":"Represents a Bell diagonal state.\n\ncoords: Coordinates in Bell basis.\ndensityMatrix: Hermitian density matrix in computational basis.\neClass: Entanglement class of the represented state.\n\n\n\n\n\n","category":"type"},{"location":"library/#BellDiagonalQudits.StandardBasis","page":"Library","title":"BellDiagonalQudits.StandardBasis","text":"Represents a Bell basis related to Weyl operators.\n\nbasis: Array with elements containing Bell basis density matrices, Weyl- and flat indices.\n\n\n\n\n\n","category":"type"},{"location":"library/#BellDiagonalQudits.eClassConflictException","page":"Library","title":"BellDiagonalQudits.eClassConflictException","text":"Exception for conflicts in analysis results.\n\nstate: The AnalysedCoordState for which a conflict occurs.\n\n\n\n\n\n","category":"type"},{"location":"library/#BellDiagonalQudits.analyseCoordState","page":"Library","title":"BellDiagonalQudits.analyseCoordState","text":"analyseCoordState(\n    d,\n    coordState::CoordState,\n    anaSpec::AnalysisSpecification,\n    stdBasis::StandardBasis=missing,\n    kernelPolytope::Union{HPolytope{Float64,Array{Float64,1}},VPolytope{Float64,Array{Float64,1}},Missing}=missing,\n    bipartiteWeylBasis::Union{Vector{Array{Complex{Float64},2}},Missing}=missing,\n    dictionaries::Union{Any,Missing}=missing,\n    mubSet::Union{Vector{Vector{Vector{ComplexF64}}},Missing}=missing,\n    boundedEWs::Union{Array{BoundedCoordEW},Missing}=missing,\n    precision=10,\n    relUncertainity=0.0\n)\n\nReturn an AnalysedCoordState for a coordState in d dimensions based on the given anaSpec and corresponding analysis objects.\n\nIf an entanglement check should not be carried out or if an analysis object in not passed as variable, the corresponding property in anaSpec needs to be false.  In this case, return the corresponding property of the AnalysedCoordState as missing.\n\n\n\n\n\n","category":"function"},{"location":"library/#BellDiagonalQudits.classifyAnalyzedStates!-Tuple{Array{AnalysedCoordState}}","page":"Library","title":"BellDiagonalQudits.classifyAnalyzedStates!","text":"classifyAnalyzedStates!(anaCoordStates::Array{AnalysedCoordState})\n\nSet entanglement class for array of analysedCoordStates.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.createBipartiteWeylOpereatorBasis-Tuple{Any}","page":"Library","title":"BellDiagonalQudits.createBipartiteWeylOpereatorBasis","text":"createBipartiteWeylOpereatorBasis(d)\n\nReturn vector of length d^4, containing the product basis of two Weyl operator bases as basis for the (d^2d^2) matrix space. \n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.createDensityState-Tuple{CoordState, StandardBasis}","page":"Library","title":"BellDiagonalQudits.createDensityState","text":"createDensityState(coordState::CoordState, standardBasis::StandardBasis)\n\nReturn DensityStatecontaining the density matrix in computational basis based oncoordStatecoordinates in BellstandardBasis`.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.createDictionaryFromBasis-Tuple{StandardBasis}","page":"Library","title":"BellDiagonalQudits.createDictionaryFromBasis","text":"createDictionaryFromBasis(stdBasis)\n\nReturn vector containing a dictionary and it's inverse, relating the d^2 flat indices to the double indices of stdBasis.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.createKernelPolytope-Tuple{Any, StandardBasis}","page":"Library","title":"BellDiagonalQudits.createKernelPolytope","text":"createKernelPolytope(d, standardBasis::StandardBasis)\n\nReturn LazySets.HPolytope representation of the kernel polytope for dimension d and Bell basis standardBasis.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.createRandomBoundedWits","page":"Library","title":"BellDiagonalQudits.createRandomBoundedWits","text":"createRandomBoundedWits(\n    d,\n    standardBasis::StandardBasis,\n    n,\n    sphericalOnly::Bool,\n    iterations::Integer,\n    method=Optim.NelderMead,\n    useConstrainedOpt=false\n)\n\nReturn array of n BoundedEW with d^2 standardBasis coordinates uniformly distributed in [-1, 1] if sphericalOnly is false or uniformly distributed on unit sphere otherwise.\n\nUse iterations runs to improve optimizatio with Optim.jl optimization method method.\n\n\n\n\n\n","category":"function"},{"location":"library/#BellDiagonalQudits.createRandomCoordStates","page":"Library","title":"BellDiagonalQudits.createRandomCoordStates","text":"createRandomCoordStates(nSamples, d, object=\"magicSimplex\", precision=10, roundToSteps::Int=0, nTriesMax=10000000)\n\nReturn an array of nSamples d^2 dimensional CoordStates. \n\nUse the object to specify the coordinate ranges to [0,1] for 'magicSimplex' or [0, 1/d] for 'enclosurePolytope'.  If roundToSteps > 0, round the coordinates to the vertices that divide the range in roundToSteps` equally sized sections. Be aware that the resulting distribution of points is generally not uniform.\n\n\n\n\n\n","category":"function"},{"location":"library/#BellDiagonalQudits.createStandardIndexBasis-Tuple{Any, Any}","page":"Library","title":"BellDiagonalQudits.createStandardIndexBasis","text":"createStandardIndexBasis(d, precision)\n\nReturn indexed Bell basis for d dimensions as StandardBasis rounded to precision digits.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.createStandardMub-Tuple{Any}","page":"Library","title":"BellDiagonalQudits.createStandardMub","text":"createStandardMub(d)\n\nReturn vector of mutually unbiased bases for dimensions d three or four.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.extendSepVPolytopeBySepStates-Tuple{LazySets.VPolytope{Float64, Vector{Float64}}, Array{DensityState}, Integer}","page":"Library","title":"BellDiagonalQudits.extendSepVPolytopeBySepStates","text":"extendSepVPolytopeBySepStates(\n    sepPolytope::VPolytope{Float64,Array{Float64,1}},\n    sepDensityStates::Array{DensityState},\n    precision::Integer\n)\n\nReturn an extended Lazysets.VPolytope representation of polytope of separable states based on given polytope sepPolytope and new separable sepDensityStates as new vertices.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.generateAllSymmetries","page":"Library","title":"BellDiagonalQudits.generateAllSymmetries","text":"generateAllSymmetries(stdBasis::StandardBasis, d, orderLimit=0)\n\nReturn array of Permutations.Permutation of all symmetries up to order orderLimit in d dimensions generated by the generators represented in standardBasis.\n\n\n\n\n\n","category":"function"},{"location":"library/#BellDiagonalQudits.getBoundedCoordEw-Tuple{BellDiagonalQudits.BoundedEW}","page":"Library","title":"BellDiagonalQudits.getBoundedCoordEw","text":"getBoundedCoordEw(bEw::BoundedEW)::BoundedCoordEW\n\nMap BoundedEW bEw to corresponding BoundedCoordEW.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.getSymCoords-Tuple{Vector{Float64}, Array{Permutations.Permutation}}","page":"Library","title":"BellDiagonalQudits.getSymCoords","text":"getSymCoords(coords::Array{Float64,1}, symPermutations::Array{Permutation})\n\nReturn array containing all symmetric Bell coordinates of given symmetries symPermutations applied to Bell coordinates coords.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.symAnalyseCoordState","page":"Library","title":"BellDiagonalQudits.symAnalyseCoordState","text":"symAnalyseCoordState(\n    d,\n    coordState::CoordState,\n    symmetries::Array{Permutation},\n    anaSpec::AnalysisSpecification,\n    stdBasis::StandardBasis=missing,\n    kernelPolytope::Union{HPolytope{Float64,Array{Float64,1}},VPolytope{Float64,Array{Float64,1}},Missing}=missing,\n    bipartiteWeylBasis::Union{Vector{Array{Complex{Float64},2}},Missing}=missing,\n    dictionaries::Union{Any,Missing}=missing,\n    mubSet::Union{Vector{Vector{Vector{ComplexF64}}},Missing}=missing,\n    boundedCoordEWs::Union{Array{BoundedCoordEW},Missing}=missing,\n    precision=10,\n    relUncertainity=0.0\n)\n\nReturn an AnalysedCoordState for a coordState in d dimensions based on the given anaSpec and corresponding analysis objects and symmetry analysis.\n\nIf an entanglement check should not be carried out or if an analysis object in not passed as variable, the corresponding property in anaSpec needs to be false.  In this case, return the corresponding property of the AnalysedCoordState as missing.\n\n\n\n\n\n","category":"function"},{"location":"library/#BellDiagonalQudits.uniformBellSampler","page":"Library","title":"BellDiagonalQudits.uniformBellSampler","text":"uniformBellSampler(n, d, object=\"magicSimplex\", precision=10)\n\nCreate array of n uniformly distributed d^2 Bell diagonal states represented as CoordState rounded to precision digits. \n\nUse object=\"enclosurePolytope\" to create CoordStates in the enclosure polytope, having all coords leq 1d.\n\n\n\n\n\n","category":"function"},{"location":"library/#Internal","page":"Library","title":"Internal","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [BellDiagonalQudits]\nPublic = false","category":"page"},{"location":"library/#BellDiagonalQudits.BoundedEW","page":"Library","title":"BellDiagonalQudits.BoundedEW","text":"Represents an entanglement witness W with extrema and extremizers to detect entangled Bell diagonal states.\n\ncoords: Coordinates in Bell basis.\nupperBound: Upper bound of tr W rho satisfied by all separable states rho. Violation detects entanglement.\nlowerBound: Lower bound of tr W rho satisfied by all separable states rho. Violation detects entanglement.\nmaximizingDensityMatrix: Density matrix of separable state rho in computational basis, maximizing tr W rho.\nminimizingDensityMatrix: Density matrix of separable state rho in computational basis. minimizing tr W rho.\ncheckedIterations: Number of iterations used in the optimization of bounds.\n\n\n\n\n\n","category":"type"},{"location":"library/#BellDiagonalQudits.EntanglementWitness","page":"Library","title":"BellDiagonalQudits.EntanglementWitness","text":"Represents an operator to detect Bell diagonal entangled states.\n\ncoords: Coordinates in Bell basis\noperatorMatrix: Hermitian matrix representing the linear operator in computational basis.\n\n\n\n\n\n","category":"type"},{"location":"library/#BellDiagonalQudits.calculateCorrelation","page":"Library","title":"BellDiagonalQudits.calculateCorrelation","text":"calculateCorrelation(d, mubSet::Vector{Vector{Vector{ComplexF64}}}, ρ, s=-1)\n\nBased on complete set of mutually unbiased bases mubSet, return sum of mutual predictibilities, shifted by s, for density matrix ρ in d dimensions. \n\n\n\n\n\n","category":"function"},{"location":"library/#BellDiagonalQudits.classifyEntanglement-Tuple{Any}","page":"Library","title":"BellDiagonalQudits.classifyEntanglement","text":"classifyEntanglement(analysedCoordState)\n\nReturn entanglement class of analysedCoordState. \n\nEntanglement class can be \"UNKNWON\", \"PPT_UNKNOWN\" for PPT states that can be separable or entangled, \"SEP\" for separable states, \"BOUND\" for PPT/bound entangled states or \"NPT\" for NPT/free entangled states.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.compParUnitary-Tuple{Any, Any}","page":"Library","title":"BellDiagonalQudits.compParUnitary","text":"compParUnitary(λ, d)\n\nReturn d dimensional prameterized unitary matrix from parameter matrix λ.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.concurrenceQpCheck","page":"Library","title":"BellDiagonalQudits.concurrenceQpCheck","text":"concurrenceQpCheck(coordState::CoordState, d, dictionaries, precision=10)\n\nReturn true if the quasi-pure concurrence (see concurrence.jl) is positive for a coordState and given basis dictionaries in the given precision.\n\n\n\n\n\n","category":"function"},{"location":"library/#BellDiagonalQudits.createBasisStateOperators-Tuple{Any, Any, Any}","page":"Library","title":"BellDiagonalQudits.createBasisStateOperators","text":"createBasisStateOperators(d, bellStateOperator, precision)\n\nUse maximally entangled Bell state bellStateOperator of dimension d to create Bell basis and return with corresponding flat and Weyl indices.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.createBipartiteMaxEntangled-Tuple{Any}","page":"Library","title":"BellDiagonalQudits.createBipartiteMaxEntangled","text":"createBipartiteMaxEntangled(d)\n\nReturn maximally entangled pure state of a bipartite system of dimension d^2.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.createDimElementSubLattices-Tuple{Any}","page":"Library","title":"BellDiagonalQudits.createDimElementSubLattices","text":"createDimElementSubLattices(d)\n\nReturn all sublattices with d elements represented as vector of tuples in the d^2 elements discrete phase space induced by Weyl operators.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.createHalfSphericWitnesses-Tuple{StandardBasis, Any}","page":"Library","title":"BellDiagonalQudits.createHalfSphericWitnesses","text":"createHalfSphericWitnesses(standardBasis::StandardBasis, n)\n\nReturn array of n uniformly distributed random EntanglementWitness on unit sphere represented in Bell basis standardBasis.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.createIndexSubLatticeState-Tuple{StandardBasis, Any}","page":"Library","title":"BellDiagonalQudits.createIndexSubLatticeState","text":"createIndexSubLatticeState(standardBasis::StandardBasis, subLattice)\n\nReturn collection of standardBasis elements contributing to the state corresponding to the sublattice, coordinates in Bell basis and density matrix in computational basis.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.createKernelHPolytope-Tuple{Any}","page":"Library","title":"BellDiagonalQudits.createKernelHPolytope","text":"createKernelHPolytope(vertexCoordinates)\n\nReturn LazySets.HPolytope representation of polytope defined by vertexCoordinates.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.createKernelVertexStates-Tuple{Any, StandardBasis}","page":"Library","title":"BellDiagonalQudits.createKernelVertexStates","text":"createKernelVertexStates(d, standardBasis::StandardBasis)\n\nReturn array containing collections of corresponding standardBasis indices, coordinates and density matrices for all d element sublattices in discrete phase space.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.createRandomWitnesses-Tuple{StandardBasis, Any}","page":"Library","title":"BellDiagonalQudits.createRandomWitnesses","text":"createRandomWitnesses(standardBasis::StandardBasis, n)\n\nReturn array of n uniformly distributed random EntanglementWitness represented in Bell basis standardBasis.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.createRedParamMatrixFromVector-Tuple{Any, Any}","page":"Library","title":"BellDiagonalQudits.createRedParamMatrixFromVector","text":"createRedParamMatrixFromVector(x, d)\n\nReturn parameter matrix for pure state parameterization from parameter vector x of length 2(d-1).\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.createWeylOperatorBasis-Tuple{Any}","page":"Library","title":"BellDiagonalQudits.createWeylOperatorBasis","text":"createWeylOperatorBasis(d)\n\nReturn vector of length d^2, containing the Weyl operator basis for the (dd) dimensionalmatrix space. \n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.directOptimization","page":"Library","title":"BellDiagonalQudits.directOptimization","text":"directOptimization(f, negf, method, d, iterations, constrainedOpt=false)\n\nReturn total (minimum, minimizer) and (maximum, maximizer) of iterations optimization runs of function f and its negative negf over the set of separale states using Optim.jl optimization mehtod method.\n\nOptim.jl is used for optimazation based on parameterization.jl, so f and negf are defined for 2(d-1) parameters. Supported methods include NelderMead, LBFGS and NewtonTrustRegion.\n\n\n\n\n\n","category":"function"},{"location":"library/#BellDiagonalQudits.genericVectorProduct-Tuple{Any, Any}","page":"Library","title":"BellDiagonalQudits.genericVectorProduct","text":"genericVectorProduct(A,B)\n\nFor any vectors of equal length, return sum_i AiBi, the sum of all products of elements with the same index.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.getBoundedEW","page":"Library","title":"BellDiagonalQudits.getBoundedEW","text":"getBoundedEW(d, wit::EntanglementWitness, iterations, method=Optim.NelderMead, useConstrainedOpt=false)\n\nReturn BoundedEW in d dimensions based on EntanglementWitness wit and iterations optimization runs of lower and upper bound for separable states.\n\n\n\n\n\n","category":"function"},{"location":"library/#BellDiagonalQudits.getCompRedParUnitaryFromVector-Tuple{Any, Any}","page":"Library","title":"BellDiagonalQudits.getCompRedParUnitaryFromVector","text":"getCompRedParUnitaryFromVector(x, d)\n\nReturn parameterized unitatry matrix U of dimension d and rank 1 from parameter vector x with 2(d-1) elements. \n\nUsing the first basis state of the computational basis with density matrix e_1, any pure state rho can be generated as rho = U e_1 U^dagger.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.getConcurrenceQP-Tuple{Any, Any, Any}","page":"Library","title":"BellDiagonalQudits.getConcurrenceQP","text":"getConcurrenceQP(coords, d, dictionaries)\n\nReturn quasi-pure approximation of the concurrence for a Bell diagonal state represented by coordinates coords with respect to a StandardBasis and corresponding dictionaries in d dimensions.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.getDirectFunctionsForWitTraceOptimization-Tuple{BellDiagonalQudits.EntanglementWitness, Any}","page":"Library","title":"BellDiagonalQudits.getDirectFunctionsForWitTraceOptimization","text":"getDirectFunctionsForWitTraceOptimization(wit::EntanglementWitness, d)\n\nReturn the function and its negative that calculates tr rho wit.coords, the trace of the given witness wit multiplied by a parameterized seperable state rho in d dimensions.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.getIntertwiner-Tuple{Any, Any, Any}","page":"Library","title":"BellDiagonalQudits.getIntertwiner","text":"getIntertwiner(d, k, l)\n\nReturn the tensor product W_kl otimes mathbb1_d.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.getPermutationFromMomentumInversion-Tuple{StandardBasis, Any}","page":"Library","title":"BellDiagonalQudits.getPermutationFromMomentumInversion","text":"getPermutationFromMomentumInversion(stdBasis::StandardBasis, d)\n\nReturn Permutations.Permutation of momentum inversion for d^2 dimensional vector of coordinates in Bell basis standardBasis.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.getPermutationFromQuarterRotation-Tuple{StandardBasis, Any}","page":"Library","title":"BellDiagonalQudits.getPermutationFromQuarterRotation","text":"getPermutationFromQuarterRotation(stdBasis::StandardBasis, d)\n\nReturn Permutations.Permutation of qurater rotation for d^2 dimensional vector of coordinates in Bell basis standardBasis.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.getPermutationFromTranslation-Tuple{Tuple{Int64, Int64}, StandardBasis, Any}","page":"Library","title":"BellDiagonalQudits.getPermutationFromTranslation","text":"getPermutationFromTranslation(translation::Tuple{Int,Int}, stdBasis::StandardBasis, d)\n\nReturn Permutations.Permutation of translation for d^2 dimensional vector of coordinates in Bell basis standardBasis.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.getPermutationFromVerticalShear-Tuple{StandardBasis, Any}","page":"Library","title":"BellDiagonalQudits.getPermutationFromVerticalShear","text":"getPermutationFromVerticalShear(stdBasis::StandardBasis, d)\n\nReturn Permutations.Permutationof vertical shear ford^2dimensional vector of coordinates in Bell basisstandardBasis`.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.getProperDivisors-Tuple{Int64}","page":"Library","title":"BellDiagonalQudits.getProperDivisors","text":"getProperDivisors(k:Int)\n\nReturn vector of proper divisors of k.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.getWitnessExtrema","page":"Library","title":"BellDiagonalQudits.getWitnessExtrema","text":"getWitnessExtrema(d, wit::EntanglementWitness, iterations, method, useConstrainedOpt=false)\n\nReturn optimization (see optimization.jl) results for lower and upper bound of d dimensional EntanglementWitness wit using iterations runs and Optim.jl optimization method method.\n\n\n\n\n\n","category":"function"},{"location":"library/#BellDiagonalQudits.isPPT-Tuple{Any, Any, Any}","page":"Library","title":"BellDiagonalQudits.isPPT","text":"isPPTP(ρ, d, precision)\n\nReturn true if the partial transposition of the Hermitian matrix based on the upper triangular of ρ is positive semi-definite in precision.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.isPositiveSemiDefinite-Tuple{Any, Any}","page":"Library","title":"BellDiagonalQudits.isPositiveSemiDefinite","text":"isPositiveSemiDefinite(M, precision)\n\nReturn true if the smallest eingenvalue of matrix M rounded to precision precision is not negative.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.kernelCheck-Tuple{CoordState, Union{LazySets.HPolytope{Float64, Vector{Float64}}, LazySets.VPolytope{Float64, Vector{Float64}}}}","page":"Library","title":"BellDiagonalQudits.kernelCheck","text":"kernelCheck(coordState::CoordState, kernelPolytope::Union{HPolytope{Float64,Array{Float64,1}},VPolytope{Float64,Array{Float64,1}}})\n\nReturn true if the Euclidean coordinates of the coordStateare contained in thekernelPolytope` represented in V- or H-representation.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.mapIndicesToNormCoord-Tuple{Any, Any}","page":"Library","title":"BellDiagonalQudits.mapIndicesToNormCoord","text":"mapIndicesToNormCoord(indices, D)\n\nReturn D element normalized coordinate vector with equal nonzero values at given indices.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.mubCheck-Tuple{CoordState, Any, StandardBasis, Vector{Vector{Vector{ComplexF64}}}}","page":"Library","title":"BellDiagonalQudits.mubCheck","text":"mubCheck(coordState::CoordState, d, stdBasis::StandardBasis, mubSet::Vector{Vector{Vector{ComplexF64}}})\n\nReturn true if the sum of mutual predictibilities for a mubSet (see mub.jl) of dimension d exceeds 2 for a coordState and given standardBasis.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.numericEwCheck","page":"Library","title":"BellDiagonalQudits.numericEwCheck","text":"numericEwCheck(coordState::CoordState, boundedEWs::Array{BoundedCoordEW}, relUncertainity::Float64)\n\nReturn true if any entanglement witness of boundedEWs detects the density matrix ρ as entangled.\n\nAn entanglement witness E of boundedEWs detects ρ, if the scalar product rho.coords cdot E.coords is not in [lowerBound, upperBound]. If a relUncertainity is given, the violation relative to upperBound-lowerBound needs to exceed relUncertainity` to detect entanglement. \n\n\n\n\n\n","category":"function"},{"location":"library/#BellDiagonalQudits.pptCheck","page":"Library","title":"BellDiagonalQudits.pptCheck","text":"pptCheck(coordState::CoordState, standardBasis::StandardBasis, precision=10)\n\nReturn trueif thecoordStatedefined via thestandardBasishas positive partial transposition in the givenprecision`.\n\n\n\n\n\n","category":"function"},{"location":"library/#BellDiagonalQudits.realignmentCheck","page":"Library","title":"BellDiagonalQudits.realignmentCheck","text":"realignmentCheck(coordState::CoordState, standardBasis::StandardBasis, precision=10)\n\nReturn trueif the realignedcoordStatedefined via thestandardBasishas trace norm> 1in the givenprecision`.\n\n\n\n\n\n","category":"function"},{"location":"library/#BellDiagonalQudits.roundDigits-Tuple{Any, Any}","page":"Library","title":"BellDiagonalQudits.roundDigits","text":"roundDigits(A, precision)\n\nReturn A with all elemets rounded up to precision digits.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.spinRepCheck","page":"Library","title":"BellDiagonalQudits.spinRepCheck","text":"spinRepCheck(coordState::CoordState, stdBasis::StandardBasis, bipartiteWeylBasis::Vector{Array{Complex{Float64},2}}, precision=10)\n\nReturn true and detects a coordState for a standardBasis as separbale, if its coefficiencts in the bipartiteWeylBasis have 1-norm smaller than 2 in given precision.\n\n\n\n\n\n","category":"function"},{"location":"library/#BellDiagonalQudits.weylOperator-Tuple{Any, Any, Any}","page":"Library","title":"BellDiagonalQudits.weylOperator","text":"weylOperator(d, k, l)\n\nReturn the (dd)- dimensional matrix representation of Weyl operator W_kl.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.weylTrf-NTuple{4, Any}","page":"Library","title":"BellDiagonalQudits.weylTrf","text":"weylTrf(d, ρ, k, l)\n\nApply the (kl)-th Weyl transformation of dimension d to the density matrix ρ. Return W_kl rho W_kl^dagger.\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.δ-Tuple{Any, Any}","page":"Library","title":"BellDiagonalQudits.δ","text":"δ(n,m)\n\nReturn 1 if n==m\n\n\n\n\n\n","category":"method"},{"location":"library/#BellDiagonalQudits.δ_mod-Tuple{Any, Any, Any}","page":"Library","title":"BellDiagonalQudits.δ_mod","text":"δ_mod(n,m,x)\n\nReturn 1 if n and m are congruent modulo x.\n\n\n\n\n\n","category":"method"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Package-installation","page":"Manual","title":"Package installation","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"BellDiagonalQudits can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"pkg> add BellDiagonalQudits","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The package can be loaded via","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> using BellDiagonalQudits","category":"page"},{"location":"manual/#State-generation","page":"Manual","title":"State generation","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Create a basis of maximally entangled Bell states in d dimensions, indexed by the corresponding Weyl operator and sample some random states represented by d^2 coordinates in the \"enclosurePolytope\", which is known to contain all PPT states.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"\nBell basis generation","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Create a basis and a dictionary to relate the d^2 coordinates of a Bell diagonal state to the double indices (kl) of the corresponding Weyl operator W_kl. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"myBasis = createStandardIndexBasis(d,10)\nmyBasisDict = createDictionaryFromBasis(myBasis)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"\nState sampling","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Create uniformly distributed random representations of quantum states by specifying the coordinates of the state in the created Bell basis.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"myCoordStates = uniformBellSampler(100, d, \"enclosurePolytope\")","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Create DensityStates including the density matrix represented in the computational basis.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"myDensityStates = map(x->createDensityState(x, myBasis), myCoordStates)","category":"page"},{"location":"manual/#Analysis-prerequisites","page":"Manual","title":"Analysis prerequisites","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Now create the analysis objects required for the entanglement classification.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"\nSeparable kernel polytope","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The kernel polytope is known to contain only Bell coordinates that relate to separable states.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"mySepKernel = createKernelPolytope(d, myBasis)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If additional separable states newSepDensityStates are known, the kernel polytope can be exteded to improve the kernel check for separability.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"myExtendedKernel = extendSepVPolytopeBySepStates(tovrep(mySepKernel), newSepDensityStates)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"\nWeyl operator basis","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Use the Weyl operators to construct a basis of the space of (d^2d^2) matrices.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"myWeylOperatorBasis = createBipartiteWeylOpereatorBasis(d)    ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"\nMutually unbiased bases (MUBs)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Create the MUBS using the Weyl operators to construct them from the computational basis.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"myMub = createStandardMub(d)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"\nSymmetries","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Generate entanglement class conserving symmetries represented as permutations of state coordinates in the Bell basis.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"mySyms = generateAllSymmetries(myBasis, d)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"\nEntanglement witnesses","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Generate n numerical entanglement witnesses by numerical optimization over the set of separable states. Use iterations runs to improve the determined upper and lower bounds. Other optimization methods than the default NelderMead can be used.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"myOptimizedEWs = createRandomBoundedWits(\n    d,\n    myBasis,\n    n,\n    true,\n    50\n    )","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Represent entanglement witnesses via their coordinates in Bell Basis.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"myOptimizedCoodEWs = map(x->getBoundedCoordEw(x), myOptimizedEWs)","category":"page"},{"location":"manual/#Entanglement-classification","page":"Manual","title":"Entanglement classification","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Analysis specification","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Specify, which entanglement checks to use. See properties of type AnalysisSpecification.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"myAnaSpec = AnalysisSpecification(\n    true,\n    true,\n    true,\n    true,\n    true,\n    false,\n    true,\n    false\n)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"\nApply analysis to all generated states","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If useSymmetries == false in the analysis specification myAnaSpec use analyseCoordState, else use symAnalyseCoordState to include the symmetry analysis.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"f(x) = analyseCoordState(\n    d,\n    x,\n    myAnaSpec,\n    myBasis,\n    mySepKernel,\n    myWeylOperatorBasis,\n    myBasisDict,\n    missing,\n    myOptimizedCoodEWs\n)\n\n    myAnalysedCoordStates = map(x->f(x), myCoordStates)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Finally use analysis results to set CoordState.eClass to assign the entanglement class to the states.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"classifyAnalyzedStates!(myAnalysedCoordStates)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Identify e.g. bound entangled states as ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"myBoundStates = filter(x->x.coordState.eClass == \"BOUND\", myAnalysedCoordStates)","category":"page"},{"location":"#BellDiagonalQudits.jl","page":"Home","title":"BellDiagonalQudits.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generate and analyze Bell diagonal Qudits with Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"A package for generation and entanglement classification of Bell diagonal quantum states.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bell diagonal states are generated as mixtures maximally entangled Bell states, which are related by Weyl transformations. The special propterties of these states, e.g. symmetries, allow efficient methods to be leveraged for the detection of entanglement, including its generally hard to detect form of PPT/bound entanglement.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides methods to sample states, to numerically generate entanglement witnesses and to apply and extend further criteria to detect entanglement or separability in general dimension. For a precise description of implemented methods and related research results see [1] and [2] and the references therein.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Create mixtures of maximally entangled Bell states based on Weyl transformations in any dimension\nClassify Bell diagonal states as separable, PPT/bound entangled or NPT/free entangled\nGenerate numerical entanglement witnesses for Bell diagonal states\nGenerate entanglement conserving symmetries and use them for entanglement classification","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1] Popp, C., Hiesmayr, B.C., Almost complete solution for the NP-hard separability problem of Bell diagonal qutrits, Sci Rep 12, 12472 (2022), https://doi.org/10.1038/s41598-022-16225-z","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2] Baumgartner, B., Hiesmayr, B.C., Narrenhofer, H. A special simplex in the state space for entangled qudits, J. Phys. A Math. Theor. 40, 7919 (2007), https://doi.org/10.1088/1751-8113/40/28/s03","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3] Popp, C., Hiesmayr, B.C., Bound Entanglement of Bell Diagonal Pairs of Qutrits and Ququarts: A Comparison, arXiv (2022), https://arxiv.org/abs/2209.15267","category":"page"}]
}
